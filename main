#include <iostream>
#include <SFML/Graphics.hpp>
#include <fstream>
#include <string>
#include <utility>
#include <unordered_map>
using namespace std;

/* Current idea: store foods as objects in a vector, each nutrient is variable of object
 Unordered map storing <food name, index in vector> so its faster to find the food object we're looking for

 When user selects a nutrient and food, sort vector by closeness to that foods value, so
 If you selected chicken and protein it would go thru the vector and do
 Absolute value[(chickens protein)-(current foods protein)] and sort to ascending order of that number,
 so 0 would be closest to chicken protein val
 also needs to ask user what sort they'd like to use cos thats kinda the point lol

 sorts we CANT do: binary, linear, bubble, insertion, selection, heap
 sorts to pick from: pivot, shell, radix, tim, a bunch others but these don't look too bad
 */

struct foodItem {
    string foodName;

};

void dataReader() {
    ///// VARIABLE DECLARATIONS (This can be streamlined later, I just wanted to list out everything that the file contains) /////
    ///// NOTE: The data in the CSV file ends at AL - this means we have 38 different pieces of data. We should probably determine what's actually useful for users, and toss the rest /////
    //34 total nutrients, so if we keep all of them we can cut # of foods down to ~2942 and still get 100k values
    //maybe eliminate a bunch of the repeat/super similar foods?
    //Big Three
    string category, description, nutrientBankDataNumber;
    //Randos
    string alphaCarotene, betaCarotene;
    //IMPORTANT
    string carbs, cholesterol, choline, fiber;
    //Randos
    string luteinZeaxanthin, lycopene, niacin;
    //Also important
    string protein, retinol, riboflavin, selenium, sugarTotal;
    //Rando
    string thiamin;
    //Good
    string water;
    //FATS
    string monosatFat, polySatFat, satFat, totalLipid;
    //MAJOR MINERALS
    string calcium, copper, iron, magnesium, phosphorus, potassium, sodium, zinc;
    //VITAMINS
    string vitaminA_RAE, vitaminB12, vitaminB6, vitaminC, vitaminE, vitaminK;

    ifstream inFile;
    inFile.open("ingredients.csv"); ///FIGURE OUT A WAY TO ATTACH THIS IN GITHUB///

    if (inFile.is_open()) {
        cout << "File has been opened" << endl;
    }
    else {
        cout << "ERROR: FILE NOT FOUND" << endl;
    }

    while (!inFile.eof()) {
        getline ( inFile, category, ',' );
        getline ( inFile, description, ',' );
        getline ( inFile, nutrientBankDataNumber, ',' );

        cout << "Category: " << category << endl;
        cout << "Description: " << description << endl;
        cout << "Data Number: " << nutrientBankDataNumber << endl;
    }
}

//Using (2^k)-1 as gaps, with largest gap being ~half the vector size (Hibbard's gaps)
//This gap size gives us O(n^(3/2))
//worst sort ever took me a billion years to figure out omg
//quicksort we freaking love u.... so much simpler
void shellSort(vector<pair<string, double>> &temp){
    int k = (int)log2((temp.size()/2)+1);
    int gap = pow(2,k)-1;
    while(gap>0){
        for ( int i = gap ; i < temp.size() ; i++){
            pair<string,double> minIndex = temp[i];
            int m = 0;
            for (m = i ; m >= gap && (get<1>(temp[m-gap]) > get<1>(minIndex)) ; m=m-gap){
                temp[m] = temp[m - gap];
            }
            temp[m] = minIndex;
        }
        k--;
        gap = pow(2,k)-1;
    }
}
//Modified ver of 6-Sorting Slide 122
void quickHelper(vector<pair<string, double>> temp, int lowerIndex, int upperIndex){
    //takes care of size 1 edge case
    bool swapped = false;
    int up = lowerIndex+1;
    int down = upperIndex;
    if (up < down){
        int pivotIndex = up-1;
        while(up <= down){
            //if they can be swapped
            if(get<1>(temp[up])>get<1>(temp[pivotIndex])&&get<1>(temp[down])<=get<1>(temp[pivotIndex])){
                swap(temp[up],temp[down]);
                swapped=true;
                up++;
                down--;
            }
            //up is greater, but so is down
            else if(get<1>(temp[up])>get<1>(temp[pivotIndex])&&get<1>(temp[down])>get<1>(temp[pivotIndex])){
                down--;
            }
            //down is <=, but so is up
            else if(get<1>(temp[up])<=get<1>(temp[pivotIndex])&&get<1>(temp[down])<=get<1>(temp[pivotIndex])){
                up++;
                swapped = true;
            }
            //no swapping, both must move though
            else{
                up++;
                down--;
            }
        }
        if(swapped){
            swap(temp[pivotIndex],temp[down]);
            pivotIndex = down;
            quickHelper(temp, lowerIndex, pivotIndex-1);
            quickHelper(temp, pivotIndex+1, upperIndex);
        }
        else{
            quickHelper(temp, lowerIndex, lowerIndex);
            quickHelper(temp, pivotIndex+1, upperIndex);
        }
    }
}
/*this finally works im pretty sure, will do more tests to be 100% certain
 */
void quickSort(vector<pair<string, double>> &temp){
    quickHelper(temp, 0, temp.size()-1);
}

int main() {
    cout << "Welcome to the Food Calculator 3000" << endl;
    cout << "Calculations aboutta go crazyyy" << endl << endl;

    vector<pair<string,double>> testing {make_pair("i",3),make_pair("i",4),make_pair("i",8),
                                         make_pair("i",7),make_pair("i",6),make_pair("i",2),make_pair("i",5)};
    shellSort(testing);

    vector<foodItem> foods;
    //stores each foods index in vector
    unordered_map<string, int> vectorLocation;
    //dataReader();

    /*this is generic sfml starter code just so its here, i think we would also be required
    to explain how to set sfml up w your ide in readme, idk if i can just say Make sure sfml is
     working with your ide
    */
    sf::RenderWindow window(sf::VideoMode(1600, 1200), "Food Nutrition");
    //left menu bar
    sf::RectangleShape leftBar(sf::Vector2f(400, 1200));
    leftBar.setPosition(0, 0);
    leftBar.setFillColor(sf::Color(230,230,230));

    sf::Font arial;
    arial.loadFromFile("30431287674.ttf");

    //quicksort button
    sf::CircleShape quickLeft(50);
    sf::CircleShape quickRight(50);
    sf::RectangleShape quickMiddle(sf::Vector2f(190, 100));
    quickMiddle.setPosition(100, 1000);
    quickMiddle.setFillColor(sf::Color(255,156,175));
    quickLeft.setPosition(50,1000);
    quickRight.setPosition(240,1000);
    quickLeft.setFillColor(sf::Color(255,156,175));
    quickRight.setFillColor(sf::Color(255,156,175));
    sf::Text quickSortText("Quick Sort",arial,45);
    quickSortText.setPosition(90,1020);
    quickSortText.setColor(sf::Color(50,50,50));
    quickSortText.setStyle(sf::Text::Bold);

    //shellsort button
    sf::CircleShape shellLeft(50);
    sf::CircleShape shellRight(50);
    sf::RectangleShape shellMiddle(sf::Vector2f(190, 100));
    shellMiddle.setPosition(100, 800);
    shellMiddle.setFillColor(sf::Color(255,156,175));
    shellLeft.setPosition(50,800);
    shellRight.setPosition(240,800);
    shellLeft.setFillColor(sf::Color(255,156,175));
    shellRight.setFillColor(sf::Color(255,156,175));
    sf::Text shellSortText("Shell Sort",arial,45);
    shellSortText.setPosition(100,820);
    shellSortText.setColor(sf::Color(50,50,50));
    shellSortText.setStyle(sf::Text::Bold);

    //food name user input bar
    string foodSearchInput;
    bool foodSearchClicked = false;
    sf::RectangleShape foodSearch(sf::Vector2f(300, 50));
    foodSearch.setPosition(50,300);
    foodSearch.setFillColor(sf::Color(255,255,255));
    foodSearch.setOutlineColor(sf::Color(50,50,50));
    foodSearch.setOutlineThickness(3);
    sf::Text foodSearchText(foodSearchInput,arial,35);
    foodSearchText.setPosition(60,300);
    foodSearchText.setColor(sf::Color(30,30,30));

    //nutrient name user input bar
    bool nutrientSearchClicked = false;
    string nutrientSearchInput;
    sf::RectangleShape nutrientSearch(sf::Vector2f(300, 50));
    nutrientSearch.setPosition(50,500);
    nutrientSearch.setFillColor(sf::Color(255,255,255));
    nutrientSearch.setOutlineColor(sf::Color(50,50,50));
    nutrientSearch.setOutlineThickness(3);
    sf::Text nutrientSearchText(nutrientSearchInput,arial,35);
    nutrientSearchText.setPosition(60,500);
    nutrientSearchText.setColor(sf::Color(30,30,30));

    double x = 0;
    double y =0;
    while (window.isOpen())
    {
        sf::Event event;

        while (window.pollEvent(event))
        {
            if(event.type == sf::Event::MouseButtonPressed){
                x=sf::Mouse::getPosition(window).x;
                y=sf::Mouse::getPosition(window).y;
                if((x>=50 && x<=350) && (y>=300 && y<=350)){
                    foodSearchClicked=true;
                    nutrientSearchClicked=false;
                }

                if((x>=50 && x<=350) && (y>=500 && y<=550)){
                    foodSearchClicked=false;
                    nutrientSearchClicked=true;
                }
            }

            if (event.type == sf::Event::TextEntered && foodSearchClicked)
            {
                foodSearchInput +=event.text.unicode;
                foodSearchText.setString(foodSearchInput);
            }

            if (event.type == sf::Event::TextEntered && nutrientSearchClicked)
            {
                nutrientSearchInput +=event.text.unicode;
                nutrientSearchText.setString(nutrientSearchInput);
            }

            if (event.type == sf::Event::Closed)
                window.close();
        }

        window.clear(sf::Color::White);
        window.draw(leftBar);
        window.draw(quickLeft);
        window.draw(quickRight);
        window.draw(quickMiddle);
        window.draw(shellLeft);
        window.draw(shellRight);
        window.draw(shellMiddle);
        window.draw(quickSortText);
        window.draw(shellSortText);
        window.draw(foodSearch);
        window.draw(foodSearchText);
        window.draw(nutrientSearch);
        window.draw(nutrientSearchText);
        window.display();
    }
    return 0;
}
